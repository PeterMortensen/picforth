<html lang="en">
<head>
<title>Untitled</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="Untitled">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p><hr>
Node:<a name="Top">Top</a>,
Next:<a rel=next accesskey=n href="#Preamble">Preamble</a>,
Previous:<a rel=previous accesskey=p href="#dir">(dir)</a>,
Up:<a rel=up accesskey=u href="#dir">(dir)</a>
<br>

<ul>
<li><a accesskey=1 href="#Preamble">Preamble</a>: 
<li><a accesskey=2 href="#Introduction">Introduction</a>: 
<li><a accesskey=3 href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>: 
<li><a accesskey=4 href="#Our%20first%20PicForth%20program">Our first PicForth program</a>: 
<li><a accesskey=5 href="#Compiler%20documentation">Compiler documentation</a>: 
<li><a accesskey=6 href="#Optimizations">Optimizations</a>: 
<li><a accesskey=7 href="#Examples">Examples</a>:

<p>--- The Detailed Node Listing ---

<p>Introduction

</p><li><a accesskey=8 href="#What%20is%20that%3f">What is that?</a>: 
<li><a accesskey=9 href="#Why%20this%20project%3f">Why this project?</a>: 
<li><a href="#State%20of%20the%20compiler">State of the compiler</a>: 
<li><a href="#License">License</a>: 
<li><a href="#Why%20not%20use%20Mary%3f">Why not use Mary?</a>: 
<li><a href="#Credits">Credits</a>:

<p>A very short Forth primer

</p><li><a href="#Foreword">Foreword</a>: 
<li><a href="#Words">Words</a>: 
<li><a href="#Stack%20and%20arguments%20passing">Stack and arguments passing</a>: 
<li><a href="#Memory%20access">Memory access</a>: 
<li><a href="#Constant%20and%20variables">Constant and variables</a>: 
<li><a href="#Tests">Tests</a>: 
<li><a href="#Loops">Loops</a>:

<p>Our first PicForth program

</p><li><a href="#The%20program%20itself">The program itself</a>: 
<li><a href="#Line%20by%20line%20explanation">Line by line explanation</a>: 
<li><a href="#Generated%20assembly%20code">Generated assembly code</a>: 
<li><a href="#An%20alternate%20solution">An alternate solution</a>: 
<li><a href="#Using%20inlined%20code">Using inlined code</a>:

<p>Compiler documentation

</p><li><a href="#Organisation">Organisation</a>: 
<li><a href="#Compiling">Compiling</a>: 
<li><a href="#Code">Code</a>: 
<li><a href="#Interactive%20mode">Interactive mode</a>: 
<li><a href="#Literals">Literals</a>: 
<li><a href="#Default%20base">Default base</a>: 
<li><a href="#Stack%20size">Stack size</a>: 
<li><a href="#Shifting">Shifting</a>: 
<li><a href="#Looping">Looping</a>: 
<li><a href="#Memory">Memory</a>: 
<li><a href="#Variables">Variables</a>: 
<li><a href="#Tables">Tables</a>: 
<li><a href="#Main%20program">Main program</a>: 
<li><a href="#Macros">Macros</a>: 
<li><a href="#Included%20files">Included files</a>: 
<li><a href="#Assembler">Assembler</a>: 
<li><a href="#Interrupts">Interrupts</a>: 
<li><a href="#Argument%20passing">Argument passing</a>: 
<li><a href="#Bit%20manipulation">Bit manipulation</a>: 
<li><a href="#Decrementing%20and%20incrementing%20a%20memory%20register">Decrementing and incrementing a memory register</a>: 
<li><a href="#Watchdog%20timer">Watchdog timer</a>: 
<li><a href="#Reading%20from%20or%20writing%20to%20EEPROM">Reading from or writing to EEPROM</a>: 
<li><a href="#Reading%20from%20or%20writing%20to%20flash%20memory">Reading from or writing to flash memory</a>: 
<li><a href="#Map%20and%20disassembler%20code">Map and disassembler code</a>: 
<li><a href="#Multitasking">Multitasking</a>: 
<li><a href="#Libraries">Libraries</a>: 
<li><a href="#Configuration%20word">Configuration word</a>: 
<li><a href="#Caveats%20and%20limitations">Caveats and limitations</a>:

<p>Multitasking

</p><li><a href="#Priority-based%20multitasker">Priority-based multitasker</a>: 
<li><a href="#Basic%20cooperative%20multitasker">Basic cooperative multitasker</a>:

<p>Optimizations

</p><li><a href="#Tail%20recursion">Tail recursion</a>: 
<li><a href="#Redundant%20pop%2fpush%20are%20removed">Redundant pop/push are removed</a>: 
<li><a href="#Direct-access%20and%20literal%20variants">Direct-access and literal variants</a>: 
<li><a href="#Load">Load</a>: 
<li><a href="#Condition%20inversions">Condition inversions</a>: 
<li><a href="#Bank%20switch%20optimizations">Bank switch optimizations</a>: 
<li><a href="#Operation%20retarget">Operation retarget</a>: 
<li><a href="#Bit%20test%20operations">Bit test operations</a>: 
<li><a href="#Useless%20loads%20removed%20when%20testing">Useless loads removed when testing</a>: 
<li><a href="#Increment%2fdecrement%20and%20skip%20if%20zero%20used%20when%20possible">Increment/decrement and skip if zero used when possible</a>: 
<li><a href="#Values%20are%20not%20normalized%20when%20this%20is%20not%20necessary">Values are not normalized when this is not necessary</a>:

</ul>

<p><hr>
Node:<a name="Preamble">Preamble</a>,
Next:<a rel=next accesskey=n href="#Introduction">Introduction</a>,
Previous:<a rel=previous accesskey=p href="#Top">Top</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>1 Preamble</h2>

<p>Microchip PIC 16F87x microcontrollers are very well suited for a number
of tasks.  However, the programmer is left with several choices to
program them:

<ul>
<li>Use Microchip MPLab IDE running on Microsoft Windows with the assembly
programming language. 
<li>Buy a third-party C compiler running on Microsoft Windows. 
<li>Use the <code>gputils</code> package on a Unix system and program the PIC
using the assembly language. 
<li>Use the <code>sdcc</code> C compiler on a Unix system and program the PIC in C. 
<li>Use the <code>PicForth</code> Forth compiler on a Unix system and program the
PIC in Forth. 
</ul>

<p>We do believe that the latest is a very pleasant solution for PIC
development, as Forth is particularily suited to embedded systems, and
Unix is more user-friendly for the developper.

<p><b>Warning:</b> this manual is a work-in-progress, and is in no way complete.

<p><hr>
Node:<a name="Introduction">Introduction</a>,
Next:<a rel=next accesskey=n href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>,
Previous:<a rel=previous accesskey=p href="#Preamble">Preamble</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>2 Introduction</h2>

<ul>
<li><a accesskey=1 href="#What%20is%20that%3f">What is that?</a>: 
<li><a accesskey=2 href="#Why%20this%20project%3f">Why this project?</a>: 
<li><a accesskey=3 href="#State%20of%20the%20compiler">State of the compiler</a>: 
<li><a accesskey=4 href="#License">License</a>: 
<li><a accesskey=5 href="#Why%20not%20use%20Mary%3f">Why not use Mary?</a>: 
<li><a accesskey=6 href="#Credits">Credits</a>: 
</ul>

<p><hr>
Node:<a name="What%20is%20that%3f">What is that?</a>,
Next:<a rel=next accesskey=n href="#Why%20this%20project%3f">Why this project?</a>,
Previous:<a rel=previous accesskey=p href="#Introduction">Introduction</a>,
Up:<a rel=up accesskey=u href="#Introduction">Introduction</a>
<br>

<h3>2.1 What is that?</h3>

<p>This program is a Forth compiler for the Microchip PIC 16F87x family.

<p><hr>
Node:<a name="Why%20this%20project%3f">Why this project?</a>,
Next:<a rel=next accesskey=n href="#State%20of%20the%20compiler">State of the compiler</a>,
Previous:<a rel=previous accesskey=p href="#What%20is%20that%3f">What is that?</a>,
Up:<a rel=up accesskey=u href="#Introduction">Introduction</a>
<br>

<h3>2.2 Why this project?</h3>

<p>I needed to write some code on a PIC to control a digital model railroad
system using the DCC (Digital Control Command) protocol. However, writing
it in assembly is error-prone and writing it in C is no fun as C compiled code
typically needs a lot of space.

<p>So I wrote this compiler, not for the purpose of writing a compiler, but as
a tool to write my DCC engine.

<p><hr>
Node:<a name="State%20of%20the%20compiler">State of the compiler</a>,
Next:<a rel=next accesskey=n href="#License">License</a>,
Previous:<a rel=previous accesskey=p href="#Why%20this%20project%3f">Why this project?</a>,
Up:<a rel=up accesskey=u href="#Introduction">Introduction</a>
<br>

<h3>2.3 State of the compiler</h3>

<p>The compiler does not aim to be ANS Forth compliant. It has quite a few words
already implemented, and I will implement more of them as needed. Of course,
you are welcome to contribute some (see below for license information).

<p>At this time, many words are missing from standard Forth. For example, I have
no multiply operation as I have no use for it at this time and won't spend
time to implement things I don't need (remember, Forth is a tool before
anything else).

<p><hr>
Node:<a name="License">License</a>,
Next:<a rel=next accesskey=n href="#Why%20not%20use%20Mary%3f">Why not use Mary?</a>,
Previous:<a rel=previous accesskey=p href="#State%20of%20the%20compiler">State of the compiler</a>,
Up:<a rel=up accesskey=u href="#Introduction">Introduction</a>
<br>

<h3>2.4 License</h3>

<p>The compiler is released at the moment under the GNU General Public
License version 2 (I intend to use the less restrictive BSD license in
the future, but as it is based on gforth, I have to sort out those
issues with gforth copyright holders).

<p>However, the code produced by using this compiler is not tainted by the
GPL license at all. You can do whatever you want with it, and I claim
absolutely no right on the input or output of this compiler. I encourage
to use it for whatever you want.

<p>Note that I would really like people to send me their modifications
(be they bug fixes or new features) so that I can incorporate them in
the next release.

<p><hr>
Node:<a name="Why%20not%20use%20Mary%3f">Why not use Mary?</a>,
Next:<a rel=next accesskey=n href="#Credits">Credits</a>,
Previous:<a rel=previous accesskey=p href="#License">License</a>,
Up:<a rel=up accesskey=u href="#Introduction">Introduction</a>
<br>

<h3>2.5 Why not use Mary?</h3>

<p>Mary was a great inspiration source, I even kept some of the names from it. 
However, no code has been reused, as both Forth do not have the same goal.

<p><hr>
Node:<a name="Credits">Credits</a>,
Previous:<a rel=previous accesskey=p href="#Why%20not%20use%20Mary%3f">Why not use Mary?</a>,
Up:<a rel=up accesskey=u href="#Introduction">Introduction</a>
<br>

<h3>2.6 Credits</h3>

<p>I would like to thank the following people, in no particular order:

<ul>
<li>Keith Wootten for his precious examples of how he uses a forth-ish
assembler for the PIC and his inspiration for some control structures

<li>Francisco Rodrigo Escobedo Robles for his Mary PIC Forth compiler

<li>Herman Tamas for his suggestions for some word names

<li>Daniel Serpell for his superoptimizer (a program looking for the
shortest possible sequences doing a particular job)

<li>Wojciech Zabolotny for his helpful remarks on interrupts and context saving
</ul>

<p><hr>
Node:<a name="A%20very%20short%20Forth%20primer">A very short Forth primer</a>,
Next:<a rel=next accesskey=n href="#Our%20first%20PicForth%20program">Our first PicForth program</a>,
Previous:<a rel=previous accesskey=p href="#Introduction">Introduction</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>3 A very short Forth primer</h2>

<ul>
<li><a accesskey=1 href="#Foreword">Foreword</a>: 
<li><a accesskey=2 href="#Words">Words</a>: 
<li><a accesskey=3 href="#Stack%20and%20arguments%20passing">Stack and arguments passing</a>: 
<li><a accesskey=4 href="#Memory%20access">Memory access</a>: 
<li><a accesskey=5 href="#Constant%20and%20variables">Constant and variables</a>: 
<li><a accesskey=6 href="#Tests">Tests</a>: 
<li><a accesskey=7 href="#Loops">Loops</a>: 
</ul>

<p><hr>
Node:<a name="Foreword">Foreword</a>,
Next:<a rel=next accesskey=n href="#Words">Words</a>,
Previous:<a rel=previous accesskey=p href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>,
Up:<a rel=up accesskey=u href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>
<br>

<h3>3.1 Foreword</h3>

<p>For a full introduction to the Forth programming language, please have a
look at the appropriate section of the Open Directory (maintained by
volunteers), at address
&lt;<code>http://dmoz.org/Computers/Programming/Languages/Forth/</code>&gt;. Only a
small subset of the language will be presented here, sometimes
overlooking details.

<p><hr>
Node:<a name="Words">Words</a>,
Next:<a rel=next accesskey=n href="#Stack%20and%20arguments%20passing">Stack and arguments passing</a>,
Previous:<a rel=previous accesskey=p href="#Foreword">Foreword</a>,
Up:<a rel=up accesskey=u href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>
<br>

<h3>3.2 Words</h3>

<p>The Forth programming language may look unusual to people used to other
languages. First of all, the actions to execute are spelled one after
each other. The sentence <code>init mainloop cleanup</code> will call, in
turn, the word <code>init</code>, the word <code>mainloop</code> then the word
<code>cleanup</code>.

<p>To define a new word, the <code>:</code> defining word is used, while the
<code>;</code> word ends the definition. The following code defines a new word
<code>doit</code> which factors the three words used above:

<br><pre>: doit init mainloop cleanup ;
</pre>

<p>After it has been defined, the word <code>doit</code> can be called as other
words by using its name. A Forth program is a collection of
application-specific words. Each word, made of other words, will be used
in turn to define new words, until the whole solution is described.

<p>Words are similar to subprograms in more conventional programming
languages. Any non-blank character can be part of a word name. For
example, <code>\</code>, <code>^</code>, or <code>$</code> are legal characters in a word
name, and can even be a word name by themselves.

<p><hr>
Node:<a name="Stack%20and%20arguments%20passing">Stack and arguments passing</a>,
Next:<a rel=next accesskey=n href="#Memory%20access">Memory access</a>,
Previous:<a rel=previous accesskey=p href="#Words">Words</a>,
Up:<a rel=up accesskey=u href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>
<br>

<h3>3.3 Stack and arguments passing</h3>

<p>In Forth, one does not use parenthesis to give arguments to called
words. Instead, a stack is used, where the arguments can be pushed and
where they can be popped from.

<p>The word <code>+</code> pops two arguments from the top of the
stack and pushes their sum. To push an integer to the top of the stack,
one writes its value. The sentence <code>3 5 +</code> will push
<code>3</code> on the stack, then <code>5</code>, and calls the word <code>+</code> which
removes <code>3</code> and <code>5</code> and pushes <code>8</code>.

<p>Some words do manipulate the stack explicitely. <code>dup</code> duplicates
the element at the top of the stack, while <code>drop</code> removes
it. <code>swap</code> exchanges the two top elements. The following word that
we name <code>2*</code> (remember that this name is perfectly valid in Forth)
does multiply the top of the stack by two, by adding it to itself:
<br><pre>: 2* dup + ;
</pre>

<p>The stack effect of a word is often written as a comment between
parenthesis; those comments are ignored by the Forth compiler. The
previously defined word could have been written:
<br><pre>: 2* ( n -- 2*n ) dup + ;
</pre>

<p>Elements on the stack are represented from left to right (top of the
stack). For example, the <code>-</code> word which substract the top of the
stack from the second element on the stack would have a stack comment
looking like <code>( n1 n2 -- n1-n2 )</code>.

<p>Let's assume that you want to multiply the top of the stack by four. You
can define the <code>4*</code> word as:
<br><pre>: 4* ( n -- 4*n ) dup + dup + ;
</pre>

<p>But remember that you can define your own words from existing words. If you
now need a word which multiplies the top of the stack by four, you can
use your previously defined <code>2*</code> word:
<br><pre>: 4* ( n -- 4*n) 2* 2* ;
</pre>

<p>Definitions in Forth tend to be very short. The grouping of common parts
in words is called <b>factoring</b>, and leads to very concise machine code.

<p><hr>
Node:<a name="Memory%20access">Memory access</a>,
Next:<a rel=next accesskey=n href="#Constant%20and%20variables">Constant and variables</a>,
Previous:<a rel=previous accesskey=p href="#Stack%20and%20arguments%20passing">Stack and arguments passing</a>,
Up:<a rel=up accesskey=u href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>
<br>

<h3>3.4 Memory access</h3>

<p>Two useful words allow you to access memory. <code>@</code> gets the
content of the memory byte whose address is at the top of the stack and
<code>!</code> stores, in the memory byte whose address is at the top of the
stack, the following element.

<p>The code below defines a word <code>mirror</code> which mirrors the content of
port A into port B (we will later see more practical ways of defining
some of the words seen here):
<br><pre>: porta 5 ;
: portb 6 ;
: mirror porta @ portb ! ;
</pre>

<p><hr>
Node:<a name="Constant%20and%20variables">Constant and variables</a>,
Next:<a rel=next accesskey=n href="#Tests">Tests</a>,
Previous:<a rel=previous accesskey=p href="#Memory%20access">Memory access</a>,
Up:<a rel=up accesskey=u href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>
<br>

<h3>3.5 Constant and variables</h3>

<p>The defining word <code>constant</code> allows you to define named
constants. Using this word, one can simplify the above example:
<br><pre>5 constant porta
6 constant portb
: mirror porta @ portb ! ;
</pre>

<p>The defining word <code>variable</code> reserves a byte in the PIC RAM and
gives it a name:
<br><pre>5 constant porta
variable counter
: increment-counter counter @ 1 + counter ! ;
: counter-to-porta counter @ porta ! ;
</pre>

<p><hr>
Node:<a name="Tests">Tests</a>,
Next:<a rel=next accesskey=n href="#Loops">Loops</a>,
Previous:<a rel=previous accesskey=p href="#Constant%20and%20variables">Constant and variables</a>,
Up:<a rel=up accesskey=u href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>
<br>

<h3>3.6 Tests</h3>

<p>Testing in Forth is done using a <code>if</code> construct, terminated by a
<code>then</code>, with an optional <code>else</code>. Operators such as <code>&lt;</code> or
<code>=</code> can be used, and any non-null value is considered as true. The
<code>abs</code> word changes the value on top of the stack to its absolute
value (note that <code>abs</code> and <code>negate</code> are in fact already
defined by PicForth):
<br><pre>: negate 0 swap - ;
: abs dup 0 &lt; if negate then ;
</pre>

<p>The word <code>mirror </code>duplicates port A to port B or port C, depending on
its argument; <code>0</code> for port B, anything else for port C
(<code>porta</code>, <code>portb</code> and <code>portc</code> constant are already
defined in PicForth):
<br><pre>: mirror ( n -- ) porta @ swap if portb ! else portc ! then ;
</pre>

<p><hr>
Node:<a name="Loops">Loops</a>,
Previous:<a rel=previous accesskey=p href="#Tests">Tests</a>,
Up:<a rel=up accesskey=u href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>
<br>

<h3>3.7 Loops</h3>

<p>Several looping constructs are used in PicForth. The first of them is
built upon <code>begin</code> and <code>again</code>, which here calls
<code>do-one-thing</code> indefinitely:
<br><pre>: mainloop begin do-one-thing again ;
</pre>

<p><code>while</code> and <code>repeat</code> can add a test in the loop and continue
as long as the word <code>continue?</code> returns a non-null result:
<br><pre>: mainloop begin do-one-thing continue? while repeat ;
</pre>

<p>Note that <code>while</code> can be present anywhere between <code>begin</code> and
<code>repeat</code>, letting you build elaborate constructs. Also,
<code>until</code> allows you to wait for a condition. The following word
calls <code>do-one-thing</code> until <code>end?</code> returns a non-null value:
<br><pre>: mainloop begin do-one-thing end? until ;
</pre>

<p>The last construct seen here is built around <code>v-for</code> and
<code>v-next</code>. <code>v-for</code> takes a (non-included) high bound and a
variable address on the stack. The following word <code>main</code> calls
<code>do-one-thing</code> 10 times:
<br><pre>variable count
: main 10 count v-for do-one-thing count v-next ;
</pre>

<p><hr>
Node:<a name="Our%20first%20PicForth%20program">Our first PicForth program</a>,
Next:<a rel=next accesskey=n href="#Compiler%20documentation">Compiler documentation</a>,
Previous:<a rel=previous accesskey=p href="#A%20very%20short%20Forth%20primer">A very short Forth primer</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>4 Our first PicForth program</h2>

<ul>
<li><a accesskey=1 href="#The%20program%20itself">The program itself</a>: 
<li><a accesskey=2 href="#Line%20by%20line%20explanation">Line by line explanation</a>: 
<li><a accesskey=3 href="#Generated%20assembly%20code">Generated assembly code</a>: 
<li><a accesskey=4 href="#An%20alternate%20solution">An alternate solution</a>: 
<li><a accesskey=5 href="#Using%20inlined%20code">Using inlined code</a>: 
</ul>

<p><hr>
Node:<a name="The%20program%20itself">The program itself</a>,
Next:<a rel=next accesskey=n href="#Line%20by%20line%20explanation">Line by line explanation</a>,
Previous:<a rel=previous accesskey=p href="#Our%20first%20PicForth%20program">Our first PicForth program</a>,
Up:<a rel=up accesskey=u href="#Our%20first%20PicForth%20program">Our first PicForth program</a>
<br>

<h3>4.1 The program itself</h3>

<p>Our first PicForth program will generate a rectangle wave signal on port
B0 as fast as possible:
<br><pre>0 pin-b i/o
: init i/o &gt;output ;
: pulse i/o high i/o low ;
: mainloop begin pulse again ;
main : program init mainloop ;
</pre>

<p><hr>
Node:<a name="Line%20by%20line%20explanation">Line by line explanation</a>,
Next:<a rel=next accesskey=n href="#Generated%20assembly%20code">Generated assembly code</a>,
Previous:<a rel=previous accesskey=p href="#The%20program%20itself">The program itself</a>,
Up:<a rel=up accesskey=u href="#Our%20first%20PicForth%20program">Our first PicForth program</a>
<br>

<h3>4.2 Line by line explanation</h3>

<p>The first line <code>0 pin-b i/o</code> defines a new word <code>i/o</code> which,
when executed, will push two integers <code>6</code> (corresponding to portb)
and <code>0</code> on the stack. This way, instead of writing <code>portb 0</code>
to manipulate bit 0 of port B you can write <code>i/o</code>, which is shorter
and lets you change it at only one place should you want to change which
port is used.

<p>The second line uses the PicForth word <code>&gt;output</code> which sets the
port whose address and bit are on the stack in output mode. This defines
a new <code>init</code> word which initializes our port B0 as an output.

<p>The third line creates a new word <code>pulse</code> which uses the PicForth
words <code>high</code> and <code>low</code> to set a pin high or low. As a result,
executing the <code>pulse</code> word will set the B0 pin high then low, this
generating a pulse.

<p>The fourth line defines a <code>mainloop</code> word which calls <code>pulse</code>
endlessly, thus generating the rectangle wave signal we want.

<p>The last line uses the PicForth word <code>main</code>. This word indicates to
PicForth that the next word to be defined will be the one to call on
reset. The word, called <code>program</code> here, calls <code>init</code> then
<code>mainloop</code>. As <code>mainloop</code> never returns, the program runs
until the end of time (which is usually considered quite a long time).

<p><hr>
Node:<a name="Generated%20assembly%20code">Generated assembly code</a>,
Next:<a rel=next accesskey=n href="#An%20alternate%20solution">An alternate solution</a>,
Previous:<a rel=previous accesskey=p href="#Line%20by%20line%20explanation">Line by line explanation</a>,
Up:<a rel=up accesskey=u href="#Our%20first%20PicForth%20program">Our first PicForth program</a>
<br>

<h3>4.3 Generated assembly code</h3>

<p>The generated code looks like:
<br><pre>0x0000  018A    clrf    0x0A
0x0001  280C    goto    0x00C   ; (init-picforth)
0x0002  0000    nop
        ; name: init
        ; max return-stack depth: 0
0x0003  1683    bsf     0x03,5
0x0004  1006    bcf     0x06,0
0x0005  1283    bcf     0x03,5
0x0006  0008    return
        ; name: pulse
        ; max return-stack depth: 0
0x0007  1406    bsf     0x06,0
0x0008  1006    bcf     0x06,0
0x0009  0008    return
        ; name: mainloop
        ; max return-stack depth: 1
0x000A  2007    call    0x007   ; pulse
0x000B  280A    goto    0x00A   ; mainloop (rs depth: 1)
        ; name: (init-picforth)
        ; max return-stack depth: 0
0x000C  3032    movlw   0x32
0x000D  0084    movwf   0x04
        ; name: program
        ; max return-stack depth: 1
0x000E  2003    call    0x003   ; init
0x000F  280A    goto    0x00A   ; mainloop (rs depth: 1)
</pre>

<p><hr>
Node:<a name="An%20alternate%20solution">An alternate solution</a>,
Next:<a rel=next accesskey=n href="#Using%20inlined%20code">Using inlined code</a>,
Previous:<a rel=previous accesskey=p href="#Generated%20assembly%20code">Generated assembly code</a>,
Up:<a rel=up accesskey=u href="#Our%20first%20PicForth%20program">Our first PicForth program</a>
<br>

<h3>4.4 An alternate solution</h3>

<p>Of course, it is possible to write less factored code for such a
simple task, and write instead:
<br><pre>0 pin-b i/o
main : program i/o &gt;output begin i/o high i/o low repeat ;
</pre>

<p>In this case, it generates effectively a code which is a bit shorter:
<br><pre>0x0000  018A    clrf    0x0A
0x0001  2803    goto    0x003   ; (init-picforth)
0x0002  0000    nop
        ; name: (init-picforth)
        ; max return-stack depth: 0
0x0003  3032    movlw   0x32
0x0004  0084    movwf   0x04
        ; name: program
        ; max return-stack depth: 0
0x0005  1683    bsf     0x03,5
0x0006  1006    bcf     0x06,0
0x0007  1283    bcf     0x03,5
0x0008  1406    bsf     0x06,0
0x0009  1006    bcf     0x06,0
0x000A  2808    goto    0x008   ; program + 0x003
</pre>

<p>However, do not let this short example mislead you. While the code looks
more efficient and shorter (and it is), this is generally not true for
real-life programs. For example, in a bigger program it would be quite
common to have to call <code>pulse</code> from other places.

<p><hr>
Node:<a name="Using%20inlined%20code">Using inlined code</a>,
Previous:<a rel=previous accesskey=p href="#An%20alternate%20solution">An alternate solution</a>,
Up:<a rel=up accesskey=u href="#Our%20first%20PicForth%20program">Our first PicForth program</a>
<br>

<h3>4.5 Using inlined code</h3>

<p>It is possible to use inlined code by surrounding the words you want to
inline by the <code>macro</code> and <code>target</code> words:
<br><pre>0 pin-b i/o
macro
: init i/o &gt;output ;
: pulse i/o high i/o low ;
: mainloop begin pulse again ;
target
main : program init mainloop ;
</pre>

<p>While this code is highly factored and easily maintainable, it generates
the very same code as the less-factored version above.

<p><hr>
Node:<a name="Compiler%20documentation">Compiler documentation</a>,
Next:<a rel=next accesskey=n href="#Optimizations">Optimizations</a>,
Previous:<a rel=previous accesskey=p href="#Our%20first%20PicForth%20program">Our first PicForth program</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>5 Compiler documentation</h2>

<ul>
<li><a accesskey=1 href="#Organisation">Organisation</a>: 
<li><a accesskey=2 href="#Compiling">Compiling</a>: 
<li><a accesskey=3 href="#Code">Code</a>: 
<li><a accesskey=4 href="#Interactive%20mode">Interactive mode</a>: 
<li><a accesskey=5 href="#Literals">Literals</a>: 
<li><a accesskey=6 href="#Default%20base">Default base</a>: 
<li><a accesskey=7 href="#Stack%20size">Stack size</a>: 
<li><a accesskey=8 href="#Shifting">Shifting</a>: 
<li><a accesskey=9 href="#Looping">Looping</a>: 
<li><a href="#Memory">Memory</a>: 
<li><a href="#Variables">Variables</a>: 
<li><a href="#Tables">Tables</a>: 
<li><a href="#Main%20program">Main program</a>: 
<li><a href="#Macros">Macros</a>: 
<li><a href="#Included%20files">Included files</a>: 
<li><a href="#Assembler">Assembler</a>: 
<li><a href="#Interrupts">Interrupts</a>: 
<li><a href="#Argument%20passing">Argument passing</a>: 
<li><a href="#Bit%20manipulation">Bit manipulation</a>: 
<li><a href="#Decrementing%20and%20incrementing%20a%20memory%20register">Decrementing and incrementing a memory register</a>: 
<li><a href="#Watchdog%20timer">Watchdog timer</a>: 
<li><a href="#Reading%20from%20or%20writing%20to%20EEPROM">Reading from or writing to EEPROM</a>: 
<li><a href="#Reading%20from%20or%20writing%20to%20flash%20memory">Reading from or writing to flash memory</a>: 
<li><a href="#Map%20and%20disassembler%20code">Map and disassembler code</a>: 
<li><a href="#Multitasking">Multitasking</a>: 
<li><a href="#Libraries">Libraries</a>: 
<li><a href="#Configuration%20word">Configuration word</a>: 
<li><a href="#Caveats%20and%20limitations">Caveats and limitations</a>: 
</ul>

<p><hr>
Node:<a name="Organisation">Organisation</a>,
Next:<a rel=next accesskey=n href="#Compiling">Compiling</a>,
Previous:<a rel=previous accesskey=p href="#Compiler%20documentation">Compiler documentation</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.1 Organisation</h3>

<p>The stack is indexed by the only indirect register, fsr. The indf register
automatically points to the top of stack.

<p>The w register is used as a scratch. Attempts to use it to cache the
top of stack proved to be inefficient, as we often need a scratch register.

<p><hr>
Node:<a name="Compiling">Compiling</a>,
Next:<a rel=next accesskey=n href="#Code">Code</a>,
Previous:<a rel=previous accesskey=p href="#Organisation">Organisation</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.2 Compiling</h3>

<p>The compiler is hosted on gforth, a free software compiler for Unix
systems.  The command line to use to compile file <code>foo.fs</code> into
<code>foo.hex</code>, and getting a usable map into foo.map is:

<br><pre>  gforth picforth.fs -e 'include foo.fs file-dump foo.hex map bye' | \
     sort -o foo.map
</pre>

<p>Of course, you should automate this in a Makefile, such as the one provided
with the compiler.

<p>If you install the GNU PIC utils (from http://gputils.sourceforge.net/),
then you can read the assembled code by using <code>gpdasm</code>.

<p><hr>
Node:<a name="Code">Code</a>,
Next:<a rel=next accesskey=n href="#Interactive%20mode">Interactive mode</a>,
Previous:<a rel=previous accesskey=p href="#Compiling">Compiling</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.3 Code</h3>

<p>The whole code space can be used. However, code generated in the first
2048 words is more efficient than the code generated in the following
2048 words; both are more efficient than the code generated for the
remaining words. This is due to the PIC architecture which does not
allow to see the code space as a flat zone.

<p><hr>
Node:<a name="Interactive%20mode">Interactive mode</a>,
Next:<a rel=next accesskey=n href="#Literals">Literals</a>,
Previous:<a rel=previous accesskey=p href="#Code">Code</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.4 Interactive mode</h3>

<p>By executing

<br><pre>  gforth picforth.fs -e 'host picquit'
</pre>

<p>(or <code>make interactive</code> from a Unix shell), you are dropped into an
interactive mode, where you can use the following words to check your code:

<br><pre>  see ( "name" -- )    Disassemble a word
  map ( -- )           Print code memory map
  dis ( -- )           Disassemble the whole code section
</pre>

<p><hr>
Node:<a name="Literals">Literals</a>,
Next:<a rel=next accesskey=n href="#Default%20base">Default base</a>,
Previous:<a rel=previous accesskey=p href="#Interactive%20mode">Interactive mode</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.5 Literals</h3>

<p>Hexadecimal literals should be prefixed by a dollar sign <code>$</code> to avoid
confusion with existing constants (such as <code>c</code> for carry bit). This is a
strong advice.

<p><hr>
Node:<a name="Default%20base">Default base</a>,
Next:<a rel=next accesskey=n href="#Stack%20size">Stack size</a>,
Previous:<a rel=previous accesskey=p href="#Literals">Literals</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.6 Default base</h3>

<p>The default base is hexadecimal. Do not change it before including libraries
bundled with the compiler, as they do expect hexadecimal mode.

<p><hr>
Node:<a name="Stack%20size">Stack size</a>,
Next:<a rel=next accesskey=n href="#Shifting">Shifting</a>,
Previous:<a rel=previous accesskey=p href="#Default%20base">Default base</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.7 Stack size</h3>

<p>The default stack size is 16. If you use the multitasker included in
<code>multitasker.fs</code> (see below), each task gets an additionnal 8 bytes of
task-specific stack.

<p>You can change the default stack size by using

<br><pre>  set-stack-size ( n -- )
</pre>

<p>in interpretation mode before using <code>main</code>.

<p><hr>
Node:<a name="Shifting">Shifting</a>,
Next:<a rel=next accesskey=n href="#Looping">Looping</a>,
Previous:<a rel=previous accesskey=p href="#Stack%20size">Stack size</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.8 Shifting</h3>

<p><code>rlf-tos</code> and <code>rrf-tos</code> respectively shift the top-of-stack
left and right, with the carry entering the byte and the outgoing bit
entering the carry.

<p><code>rlf!</code> and <code>rrf!</code> respectively shift the given variable left
and right, with the carry entering the byte and the outgoing bit entering
the carry.

<p><code>lshift</code> and <code>rshift</code> used with a constant shift, and
<code>2*</code> and <code>2/</code> do have the last exited bit in the carry.

<p><code>swapf-tos</code> will swap the upper and lower nibble of the top-of-stack.

<p><hr>
Node:<a name="Looping">Looping</a>,
Next:<a rel=next accesskey=n href="#Memory">Memory</a>,
Previous:<a rel=previous accesskey=p href="#Shifting">Shifting</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.9 Looping</h3>

<p>There exists a <code>v-for</code>/<code>v-next</code> structure (v stands for variable):

<br><pre>  v-for ( n addr -- )
    Initialize addr content with n.

  v-next ( -- )
    Decrement addr content. If content is not zero,
    jump to v-for location.
</pre>

<p>The address has to be located in bank 0.

<p>Also, the words <code>begin</code>, <code>again</code>, <code>while</code>, <code>until</code>
and <code>repeat</code> are implemented.

<p><hr>
Node:<a name="Memory">Memory</a>,
Next:<a rel=next accesskey=n href="#Variables">Variables</a>,
Previous:<a rel=previous accesskey=p href="#Looping">Looping</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.10 Memory</h3>

<p>You can choose the memory bank that will be used by the memory commands
in interpretation mode by using the words <code>bank0</code>, <code>bank1</code>,
<code>bank2</code> and <code>bank3</code> (check that it applies to your device
first).

<p>Those commands do affect the subsequent <code>create</code>, <code>variable</code>,
<code>allot</code>, <code>,</code> and <code>here</code> commands. However, note that you
can only access indirectly variables located in bank 0 or in bank
1. Locations in other banks must be accessed using their static
addresses.

<p>You can define your own memory sections using the words <code>section</code>,
<code>idata</code> and <code>udata</code>. No check will be made to ensure that
those sections do not overlap.

<p><hr>
Node:<a name="Variables">Variables</a>,
Next:<a rel=next accesskey=n href="#Tables">Tables</a>,
Previous:<a rel=previous accesskey=p href="#Memory">Memory</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.11 Variables</h3>

<p>Variables are not automatically initialized to zero, as this would waste
too much code if it is not needed. If you want a variable explicitely
initialized, use <code>create</code> and <code>,</code> such as in:

<br><pre>  create attempts 3 ,
</pre>

<p><hr>
Node:<a name="Tables">Tables</a>,
Next:<a rel=next accesskey=n href="#Main%20program">Main program</a>,
Previous:<a rel=previous accesskey=p href="#Variables">Variables</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.12 Tables</h3>

<p>Tables can be created either in RAM (with run-time initialization, which
is costly), in program flash memory or in the internal EEPROM.

<p>The following words allow you to create tables:

<br><pre>  table      ( "name" -- )        Start a RAM table
  ftable     ( "name" -- )        Start a program flash table
  eetable    ( "name" -- )        Start an EEPROM flash table
  t,         ( n -- )             Add one byte to the table
  table&gt;     ( "b1 .. bn" -- )    Add bytes b1 to bn to the table
  end-table  ( -- )               End table declaration
</pre>

<p>The following code shows a table called <code>substitutions</code> and a
<code>substitute</code> word which takes a byte in area <code>old-key</code> and
sets it at the right place in area <code>new-key</code>, according to the
<code>substitutions</code> table.

<br><pre>ftable substitutions
 table&gt; 14 4 13 1 2 15 11 8 3 10 6 12 5 9 0 7
 table&gt; 0 15 7 4 14 2 13 1 12 6 12 11 9 5 3 8
 table&gt; 4 1 14 8 13 6 2 11 15 12 9 7 3 10 5 0
 table&gt; 15 12 8 2 4 9 1 7 5 11 3 14 10 0 6 13
end-table

: substitute ( n -- ) dup old-key +  swap substitutions new-key + ! ;
</pre>

<p><hr>
Node:<a name="Main%20program">Main program</a>,
Next:<a rel=next accesskey=n href="#Macros">Macros</a>,
Previous:<a rel=previous accesskey=p href="#Tables">Tables</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.13 Main program</h3>

<p>A <code>main</code> word indicates that the next address is the main program. Use for
example:

<br><pre>  main : main-program ( -- )
    (do initialisations)
    (call mainloop)
  ;
</pre>

<p><hr>
Node:<a name="Macros">Macros</a>,
Next:<a rel=next accesskey=n href="#Included%20files">Included files</a>,
Previous:<a rel=previous accesskey=p href="#Main%20program">Main program</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.14 Macros</h3>

<p>You can switch to macro mode by using the <code>macro</code> word. You get back to
target mode by using the <code>target</code> word.

<p><hr>
Node:<a name="Included%20files">Included files</a>,
Next:<a rel=next accesskey=n href="#Assembler">Assembler</a>,
Previous:<a rel=previous accesskey=p href="#Macros">Macros</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.15 Included files</h3>

<p>You can include files using <code>include file</code> or <code>needs
file</code> (which prevents from multiple inclusions to happen).

<p><hr>
Node:<a name="Assembler">Assembler</a>,
Next:<a rel=next accesskey=n href="#Interrupts">Interrupts</a>,
Previous:<a rel=previous accesskey=p href="#Included%20files">Included files</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.16 Assembler</h3>

<p>There is a full prefix assembler included. Use <code>code</code> and
<code>end-code</code> to define words written in assembler. <code>]asm</code> and
<code>asm[</code> let you respectively switch to assembler mode and back
during the compilation of a Forth word.

<p>The <code>label:</code> defining word can be used to define a label that will
then be used with <code>goto</code>. See the <code>piceeprom.fs</code> file for an
example.

<p><hr>
Node:<a name="Interrupts">Interrupts</a>,
Next:<a rel=next accesskey=n href="#Argument%20passing">Argument passing</a>,
Previous:<a rel=previous accesskey=p href="#Assembler">Assembler</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.17 Interrupts</h3>

<p>If you want to use interrupts, use

<br><pre>  include picisr.fs
</pre>

<p>Two words do respectively save and restore the context around interrupt
handling code:

<br><pre>  isr-save ( -- )
  isr-restore-return ( -- )
</pre>

<p>Note that <code>isr-save</code> is called automatically, you do not need to
call it explicitely.

<p>Also, the word <code>isr</code> is provided to notify that the next address is the
isr handler.

<p>For example, you can write an interrupt handler with:

<br><pre>  isr : interrupt-handler ( -- )
    (interrupt handling code here)
    isr-restore-return
  ;
</pre>

<p>Do not forget that the return stack depth is only height. An interrupt can
occur at any time unless you mask them or unset the GIE bit.

<p>Two facility words that manipulate GIE are also provided:

<br><pre>  enable-interrupts ( -- )
  disable-interrupts ( -- )
</pre>

<p>You have to dispatch the interrupts and clear the interrupt bits manually
before you return from the handler.

<p>You can also use the following two words to save the status of the GIE
bit and disable interrupts, and to restore the previous GIE status:

<br><pre>  suspend-interrupts ( -- )
  restore-interrupts ( -- )
</pre>

<p>Versions that do nothing are provided in the default compiler. Useful versions
are redefined when using <code>picisr.fs</code>.

<p>Because of this, include <code>picisr.fs</code> as soon as possible,
before other files and before using enable-interrupts and
disable-interrupts. Other included files may fail to act properly if you
don't.

<p><hr>
Node:<a name="Argument%20passing">Argument passing</a>,
Next:<a rel=next accesskey=n href="#Bit%20manipulation">Bit manipulation</a>,
Previous:<a rel=previous accesskey=p href="#Interrupts">Interrupts</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.18 Argument passing</h3>

<p>In Forth, argument passing is done on the stack. However, if you want to
transmit the top-of-stack argument in the w register (for example if a word
typically takes a constant which is put on the stack just before calling it),
you can use the defining word <code>::</code> instead of <code>:</code>. All calls will
automatically use this convention.

<p>If you want to return a value in the w register, you can use the word
<code>&gt;w</code> which loads the top-of-stack into the w register before every
exit point.  After calling a word which returns its result in the w
register, you can call <code>w&gt;</code> to put the w register value onto the
stack.

<p><hr>
Node:<a name="Bit%20manipulation">Bit manipulation</a>,
Next:<a rel=next accesskey=n href="#Decrementing%20and%20incrementing%20a%20memory%20register">Decrementing and incrementing a memory register</a>,
Previous:<a rel=previous accesskey=p href="#Argument%20passing">Argument passing</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.19 Bit manipulation</h3>

<p>To ease bit manipulation, the following words are defined for port p:

<br><pre>  and!       ( n p -- )    logical and with n
  /and!      ( n p -- )    logical and with ~n
  /and       ( a b -- c )  logical and of a and ~b
  or!        ( n p -- )    logical or with n
  xor!       ( n p -- )    logical xor with n
  invert!    ( p -- )      invert content
  bit-set    ( p b -- )    set bit b of p (both have to be constants)
  bit-clr    ( p b -- )    clear bit b of p (both have to be constants)
  bit-toggle ( p b -- )    toggle bit b of p (both have to be constants)
  bit-mask   ( p b -- m )  put 1&lt;&lt;b on stack
  bit-set?   ( p b -- m )  put bit-mask (non-zero) on stack if bit b of
                           p is set, zero otherwise
  bit-clr?   ( p b -- f )  true if bit b of p is clear
</pre>

<p>Six words help designate bit or port pins:

<br><pre>  bit    ( n addr "name" -- )    ( Runtime: -- addr n )
  pin-a  ( n "name" -- )         ( Runtime: -- porta n )
  pin-b  ( n "name" -- )         ( Runtime: -- portb n )
  pin-c  ( n "name" -- )         ( Runtime: -- portc n )
  pin-d  ( n "name" -- )         ( Runtime: -- portd n )
  pin-e  ( n "name" -- )         ( Runtime: -- porte n )
</pre>

<p>For example, you can create a pin designating an error LED and manipulate
it using:

<br><pre>  3 pin-b error-led                   \ Error LED is on port B3
  : error error-led bit-set ;         \ Signal error
  : no-error error-led bit-clr ;      \ Clear error
</pre>

<p>To ease reading, the words <code>high</code>, <code>low</code>, <code>high?</code>,
<code>low?</code> and <code>toggle</code> are aliases for, respectively,
<code>bit-set</code>, <code>bit-low</code>, <code>bit-set?</code>, <code>bit-clr?</code> and
<code>bit-toggle</code>.

<p>You can change the direction of a pin by using <code>&gt;input</code> or
<code>&gt;output</code> after a pin defined with <code>pin-x</code>. For example, to
set the error led port as an output, use:

<br><pre>  error-led &gt;output
</pre>

<p><hr>
Node:<a name="Decrementing%20and%20incrementing%20a%20memory%20register">Decrementing and incrementing a memory register</a>,
Next:<a rel=next accesskey=n href="#Watchdog%20timer">Watchdog timer</a>,
Previous:<a rel=previous accesskey=p href="#Bit%20manipulation">Bit manipulation</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.20 Decrementing and incrementing a memory register</h3>

<p>A value in memory can be decremented using the <code>1 mem -!</code>
sequence. However, as this will be optimized to use the <code>decf mem,f</code>
which does not position the <code>c</code> flag. Usually, this is fine,
however, if you want to propagate a carry, you want this flag to be
set. To that issue, you can use the <code>1 &gt;w mem w-!</code> sequence, which
generates <code>movlw 1; subwf mem,f</code> and position the carry.

<p>Note that propagating the carry while incrementing is easier: the
<code>z</code> flag is set if needed by the <code>incf mem,f</code> instruction
generated by the use of the <code>1 mem +!</code> sequence. If <code>z</code> is
set, a carry has been generated.

<p>Here is an example to increment a 16 bits value held at location <code>bar</code>:

<br><pre>  : inc-16 ( adder -- ) 1 bar 1+ +! z bit-set? if 1 bar +! then ;
</pre>

<p>This will generate the following code:

<br><pre>  ; name: inc-16
  incf    0x34,f
  btfsc   0x03,2
  incf    0x33,f
  return
</pre>

<p><hr>
Node:<a name="Watchdog%20timer">Watchdog timer</a>,
Next:<a rel=next accesskey=n href="#Reading%20from%20or%20writing%20to%20EEPROM">Reading from or writing to EEPROM</a>,
Previous:<a rel=previous accesskey=p href="#Decrementing%20and%20incrementing%20a%20memory%20register">Decrementing and incrementing a memory register</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.21 Watchdog timer</h3>

<p>The word <code>clrwdt</code> is available from Forth to clear the watchdog timer.

<p><hr>
Node:<a name="Reading%20from%20or%20writing%20to%20EEPROM">Reading from or writing to EEPROM</a>,
Next:<a rel=next accesskey=n href="#Reading%20from%20or%20writing%20to%20flash%20memory">Reading from or writing to flash memory</a>,
Previous:<a rel=previous accesskey=p href="#Watchdog%20timer">Watchdog timer</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.22 Reading from or writing to EEPROM</h3>

<p>By using

<br><pre>  include piceeprom.fs
</pre>

<p>you have access to new words allowing you to access the PIC EEPROM:

<br><pre>  ee@          ( a -- b )     read the content of a and return it
  ee!          ( b a -- )     write b into a
</pre>

<p>Also, in any case, you can store data in EEPROM using those words:

<br><pre>  eecreate     ( "name" -- )            similar as create but in
                                        EEPROM space
  ee,          ( b -- )                 store byte in EEPROM
  s"           ( &lt;ccc&gt;" -- eaddr n )    store string in EEPROM
  l"           ( &lt;ccc&gt;" -- eaddr n )    strore string + character 13
                                        in EEPROM
</pre>

<p><hr>
Node:<a name="Reading%20from%20or%20writing%20to%20flash%20memory">Reading from or writing to flash memory</a>,
Next:<a rel=next accesskey=n href="#Map%20and%20disassembler%20code">Map and disassembler code</a>,
Previous:<a rel=previous accesskey=p href="#Reading%20from%20or%20writing%20to%20EEPROM">Reading from or writing to EEPROM</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.23 Reading from or writing to flash memory</h3>

<p>Two words allow reading from and writing to the flash memory when the file
<code>picflash.fs</code> is included with

<br><pre>  include picflash.fs
</pre>

<p>Those words expect manipulate a 14 bits program memory cell whose 13 bits
address is in EEADRH:EEADR. The data is read from or stored to EEDATH:EEDATA.

<br><pre>  flash-read ( -- )
  flash-write ( -- )
</pre>

<p>If <code>picisr.fs</code> has been included before this file, interrupts will
be properly disabled around flash writes.

<p>The <code>libstrings.fs</code> library defines two words useful for working
with strings stored in flash memory:

<br><pre>  c" ( &lt;ccc&gt;" -- )     Define a packed 7-bits zero-terminated string
  str-char             Get next char of previously encountered c"
</pre>

<p>The following example assumes that you have a <code>emit</code> word working,
which outputs one character.

<br><pre>: print ( -- ) begin str-char dup while emit repeat drop ;
: greetings ( -- ) c" Welcome to this PicForth program" print ;
</pre>

<p>It is necessary to include <code>picflash.fs</code> before <code>libstrings.fs</code>.

<p><hr>
Node:<a name="Map%20and%20disassembler%20code">Map and disassembler code</a>,
Next:<a rel=next accesskey=n href="#Multitasking">Multitasking</a>,
Previous:<a rel=previous accesskey=p href="#Reading%20from%20or%20writing%20to%20flash%20memory">Reading from or writing to flash memory</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.24 Map and disassembler code</h3>

<p>A map can be generated in interactive mode using the <code>map</code> word.

<p><hr>
Node:<a name="Multitasking">Multitasking</a>,
Next:<a rel=next accesskey=n href="#Libraries">Libraries</a>,
Previous:<a rel=previous accesskey=p href="#Map%20and%20disassembler%20code">Map and disassembler code</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.25 Multitasking</h3>

<p>Two multitasker have been implemented.

<ul>
<li><a accesskey=1 href="#Priority-based%20multitasker">Priority-based multitasker</a>: 
<li><a accesskey=2 href="#Basic%20cooperative%20multitasker">Basic cooperative multitasker</a>: 
</ul>

<p><hr>
Node:<a name="Priority-based%20multitasker">Priority-based multitasker</a>,
Next:<a rel=next accesskey=n href="#Basic%20cooperative%20multitasker">Basic cooperative multitasker</a>,
Previous:<a rel=previous accesskey=p href="#Multitasking">Multitasking</a>,
Up:<a rel=up accesskey=u href="#Multitasking">Multitasking</a>
<br>

<h4>5.25.1 Priority-based multitasker</h4>

<p>A basic priority-based cooperative multitasker allows you to
concurrently run several indenpendant tasks. Each task should execute
in a short time and will be called again next time (the entry point
does not change). This looks like a state machine.

<p>To use this multitasker, use <code>include priotasker.fs</code> in your program.

<p>The following words can be used to define tasks (the entry point for the
task is the next defined word):

<br><pre>  task ( prio "name" -- )
                 Define a new task with priority prio. By default, this
                 task will be active. You can use the <code>start</code> and
                 <code>stop</code> words to control it. Those words can be
                 used from an interrupt handler.

  task-cond ( prio "name" -- )
                 Define a new task with priority prio. By default, this
                 task is inactive. You can enable it by using the
                 <code>signal</code> word on it. If you use <code>signal</code> N
                 times, then the task will be run exactly N
                 times. <code>signal</code> can be used from an interrupt handler.

  task-idle ( -- )
                 Define a new task which will be executed
                 inconditionnaly when there is nothing else to do. Such
                 a task can not be stopped.

  task-set ( bit port prio -- )
                 Define a new task with priority prio that will be run
                 when bit bit of port port is set.

  task-clr ( bit port prio -- )
                 Define a new task with priority prio that will be run
                 when bit bit of port port is clear.
</pre>

<p>Priority 0 is the greatest one, while priority 255 corresponds to the lowest
(idle) priority. You should use priority in the range 0-254 for your own
tasks.

<p>The multitasker is run by using the word <code>multitasker</code>. This word takes care
of scheduling the highest priority tasks first. It also clears the watchdog
once per round.

<p>The multitasker looks for all tasks of priority 0 ready to execute. If it
find some, it executes them and starts over. If it doesn't, it looks for
priority 1 tasks ready to execute. If it find some, it executes them and
starts over. If it doesn't, etc. It does this up to priority 255.

<p>Since each word is called each time from the beginning, there is no
need to maintain task-specific stacks, as the stack has to be
considered empty.

<p><hr>
Node:<a name="Basic%20cooperative%20multitasker">Basic cooperative multitasker</a>,
Previous:<a rel=previous accesskey=p href="#Priority-based%20multitasker">Priority-based multitasker</a>,
Up:<a rel=up accesskey=u href="#Multitasking">Multitasking</a>
<br>

<h4>5.25.2 Basic cooperative multitasker</h4>

<p>The basic cooperative multitasker is much simpler. It allows you to
relinguish the CPU whenever you want, provided that you are not in the
middle of a call (context-switch only occurs during top-level calls).

<p>To use this multitasker, use <code>include multitasker.fs</code> at the top of
your program. The following words are defined:

<br><pre>  task ( -- )
      Create a new task with its own data stack. The task entry point
      will be the next defined word.

  yield ( -- )
      Relinguish control so that another task gets a chance to
      execute.

  multitasker ( -- )
      Code for the multitasker program. This word never returns.
</pre>

<p>This multitasker makes no use of the return stack at all. However, each
task takes four to six program words for initialization and five program
words to resume the task, plus three or four program words per yield
instruction. Context-switching takes at most 18 instruction cycles (3.6
microseconds max on a 20MHz PIC, 18 microseconds on a 4MHz PIC), and
typically 14. Also, the multitasker takes care of clearing the watchdog
timer at each round.

<p>Each task needs 3 bytes in RAM to save its context and 8 bytes for its
data stack.

<p><hr>
Node:<a name="Libraries">Libraries</a>,
Next:<a rel=next accesskey=n href="#Configuration%20word">Configuration word</a>,
Previous:<a rel=previous accesskey=p href="#Multitasking">Multitasking</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.26 Libraries</h3>

<p>Some libraries can be used to enhance your application:

<ul>
<li><code>libnibble.fs</code>
nibbles and characters conversion

<li><code>libcmove.fs</code>
implementation of ANS Forth <code>cmove</code> word
</ul>

<p><hr>
Node:<a name="Configuration%20word">Configuration word</a>,
Next:<a rel=next accesskey=n href="#Caveats%20and%20limitations">Caveats and limitations</a>,
Previous:<a rel=previous accesskey=p href="#Libraries">Libraries</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.27 Configuration word</h3>

<p>The configuration can be configured with the following words:

<br><pre>  set-fosc   ( n -- )       Choose oscillator mode (default: fosc-rc)
     fosc-lp   Low power
     fosc-xt   External oscillator
     fosc-hs   High-speed oscillator
     fosc-rc   RC circuit
  set-wdte   ( flag -- )    Watchdog timer enable (default: true)
  set-/pwrte ( flag -- )    Power-on timer disable (default: true)
  set-boden  ( flag -- )    Brown-out detect enable (default: true)
  set-lvp    ( flag -- )    Low voltage programming (default: true)
  set-cpd    ( flag -- )    EEPROM protection disable (default: true)
  set-wrt    ( flag -- )    FLASH protection disable (default: true)
  set-debug  ( flag -- )    In-circuit debugger disable (default: true)
  set-cp     ( n -- )       Code protection (default: no-cp)
     no-cp     No protection
     full-cp   Full protection
     xxxxx     Anything you want, with the right bits set
               (see datasheet)
</pre>

<p><hr>
Node:<a name="Caveats%20and%20limitations">Caveats and limitations</a>,
Previous:<a rel=previous accesskey=p href="#Configuration%20word">Configuration word</a>,
Up:<a rel=up accesskey=u href="#Compiler%20documentation">Compiler documentation</a>
<br>

<h3>5.28 Caveats and limitations</h3>

<p>This compiler release suffers from the following known limitations. Note
that most of them (if not all) will disappear in subsequent releases.

<ul>
<li>No interactivity
There is no link between the compiler and the target. 
</ul>

<p><hr>
Node:<a name="Optimizations">Optimizations</a>,
Next:<a rel=next accesskey=n href="#Examples">Examples</a>,
Previous:<a rel=previous accesskey=p href="#Compiler%20documentation">Compiler documentation</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>6 Optimizations</h2>

<p>The following optimizations are implemented:

<ul>
<li><a accesskey=1 href="#Tail%20recursion">Tail recursion</a>: 
<li><a accesskey=2 href="#Redundant%20pop%2fpush%20are%20removed">Redundant pop/push are removed</a>: 
<li><a accesskey=3 href="#Direct-access%20and%20literal%20variants">Direct-access and literal variants</a>: 
<li><a accesskey=4 href="#Load">Load</a>: 
<li><a accesskey=5 href="#Condition%20inversions">Condition inversions</a>: 
<li><a accesskey=6 href="#Bank%20switch%20optimizations">Bank switch optimizations</a>: 
<li><a accesskey=7 href="#Operation%20retarget">Operation retarget</a>: 
<li><a accesskey=8 href="#Bit%20test%20operations">Bit test operations</a>: 
<li><a accesskey=9 href="#Useless%20loads%20removed%20when%20testing">Useless loads removed when testing</a>: 
<li><a href="#Increment%2fdecrement%20and%20skip%20if%20zero%20used%20when%20possible">Increment/decrement and skip if zero used when possible</a>: 
<li><a href="#Values%20are%20not%20normalized%20when%20this%20is%20not%20necessary">Values are not normalized when this is not necessary</a>: 
</ul>

<p><hr>
Node:<a name="Tail%20recursion">Tail recursion</a>,
Next:<a rel=next accesskey=n href="#Redundant%20pop%2fpush%20are%20removed">Redundant pop/push are removed</a>,
Previous:<a rel=previous accesskey=p href="#Optimizations">Optimizations</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.1 Tail recursion</h3>

<p>Tail recursion is implemented at <code>exit</code> and <code>;</code> points.

<br><pre>  : x y z ;
</pre>

<p>generates the following code for word x:

<br><pre>  call    y
  goto    z
</pre>

<p>The sequence <code>recurse exit</code> also benefits from tail recursion.

<p><hr>
Node:<a name="Redundant%20pop%2fpush%20are%20removed">Redundant pop/push are removed</a>,
Next:<a rel=next accesskey=n href="#Direct-access%20and%20literal%20variants">Direct-access and literal variants</a>,
Previous:<a rel=previous accesskey=p href="#Tail%20recursion">Tail recursion</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.2 Redundant pop/push are removed</h3>

<p>For example, the (particularily useless)

<br><pre>  dup dup drop
</pre>

<p>sequence generates

<br><pre>  movf     0x00,w
  decf     0x04,f
  movwf    0x00
</pre>

<p>which in fact corresponds to a single <code>dup</code>.

<p>Also, the following sequence

<br><pre>  drop 3
</pre>

<p>generates

<br><pre>  movlw    0x03
  movwf    0x00
</pre>

<p>while

<br><pre>  drop 0
</pre>

<p>gives

<br><pre> clrf      0x00
</pre>

<p><hr>
Node:<a name="Direct-access%20and%20literal%20variants">Direct-access and literal variants</a>,
Next:<a rel=next accesskey=n href="#Load">Load</a>,
Previous:<a rel=previous accesskey=p href="#Redundant%20pop%2fpush%20are%20removed">Redundant pop/push are removed</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.3 Direct-access and literal variants</h3>

<p>Most operations use direct-access and literal variants when
possible. The following sequence

<br><pre>  9 and
</pre>

<p>generates

<br><pre>  movlw    0x09
  andwf    0x00,f
</pre>

<p>Also, combined with the redundant push/pop eliminations, the following code

<br><pre>  dup 9 and if ...
</pre>

<p>generates

<br><pre>  movf    0x00,w
  andlw   0x09
  btfsc   0x03,2
</pre>

<p><hr>
Node:<a name="Load">Load</a>,
Next:<a rel=next accesskey=n href="#Condition%20inversions">Condition inversions</a>,
Previous:<a rel=previous accesskey=p href="#Direct-access%20and%20literal%20variants">Direct-access and literal variants</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.4 Load, store and operations are mixed</h3>

<p>The following sequence (with <code>current</code> and <code>next</code> being variables)

<br><pre>  current @ 1+ 7 and next !
</pre>

<p>generates

<br><pre>  movf    0x3B,w
  addlw   0x01
  andlw   0x07
  movwf   0x3C
</pre>

<p><hr>
Node:<a name="Condition%20inversions">Condition inversions</a>,
Next:<a rel=next accesskey=n href="#Bank%20switch%20optimizations">Bank switch optimizations</a>,
Previous:<a rel=previous accesskey=p href="#Load">Load</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.5 Condition inversions</h3>

<p>Short (one instruction) <code>if</code> actions are transformed into reversed
conditions. For example, the following word:

<br><pre>  \ This word clears port a0 if port c2 is high, and sets port b1
  \ in any case.
  : z portc 2 high? if porta 0 low then portb 0 high ;
</pre>

<p>generates the following code:

<br><pre>  btfsc    0x07,2  ; skip next instruction if port c2 is low
  bcf      0x05,0  ; set port a0 low
  bsf      0x06,1  ; set port b1 high
  return           ; return from word
</pre>

<p><hr>
Node:<a name="Bank%20switch%20optimizations">Bank switch optimizations</a>,
Next:<a rel=next accesskey=n href="#Operation%20retarget">Operation retarget</a>,
Previous:<a rel=previous accesskey=p href="#Condition%20inversions">Condition inversions</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.6 Bank switch optimizations</h3>

<p>The compiler tries to remove useless bank manipulations. The following word

<br><pre> :: ee@ ( addr -- n ) eeadr ! eepgd bit-set rd bit-set eedata @ ;
</pre>

<p>generates:

<br><pre>  bsf      0x03,6     ; select bank 2
  movwf    0x0d       ; write into eeadr (in bank 2)
  bsf      0x03,5     ; select bank 3
  bsf      0x0c,7     ; set bit eepgd of eecon1 (in bank 3)
  bsf      0x0c,0     ; set bit rd of eecon1 (in bank 3)
  bcf      0x03,5     ; select bank 2
  movf     0x0c,w     ; read eedata (in bank 2)
  bcf      0x03,6     ; select bank 0
  decf     0x04,f     ; decrement stack pointer
  movwf    0x00       ; place read value on top of stack
  return
</pre>

<p><hr>
Node:<a name="Operation%20retarget">Operation retarget</a>,
Next:<a rel=next accesskey=n href="#Bit%20test%20operations">Bit test operations</a>,
Previous:<a rel=previous accesskey=p href="#Bank%20switch%20optimizations">Bank switch optimizations</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.7 Operation retarget</h3>

<p>If an operation result is stored on the stack then popped into w, the
operation is modified to target w directly.

<p>For example, the following word:

<br><pre>  : timer ( n -- ) invert tmr0 ! ;
</pre>

<p>generates

<br><pre>  comf     0x00,w
  incf     0x04,f
  movwf    0x01
  return
</pre>

<p><hr>
Node:<a name="Bit%20test%20operations">Bit test operations</a>,
Next:<a rel=next accesskey=n href="#Useless%20loads%20removed%20when%20testing">Useless loads removed when testing</a>,
Previous:<a rel=previous accesskey=p href="#Operation%20retarget">Operation retarget</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.8 Bit test operations</h3>

<p>If a <code>and</code> operation before a test can be rewritten using a bit test
operation, it will.

<p>For example, the code:

<br><pre>  checksum @ 1 and if parity-error exit then ...
</pre>

<p>will be compiled as:

<br><pre>  btfsc    0x33,0
  goto     0x037      ; parity-error
  ...
</pre>

<p>Using an explicit bit-test holds the same result:

<br><pre>  porta 3 high? if exit then
</pre>

<p>will be compiled as:

<br><pre>  btfsc   0x05,3
  return
</pre>

<p><hr>
Node:<a name="Useless%20loads%20removed%20when%20testing">Useless loads removed when testing</a>,
Next:<a rel=next accesskey=n href="#Increment%2fdecrement%20and%20skip%20if%20zero%20used%20when%20possible">Increment/decrement and skip if zero used when possible</a>,
Previous:<a rel=previous accesskey=p href="#Bit%20test%20operations">Bit test operations</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.9 Useless loads removed when testing</h3>

<p>Before a test, if the z status bit already holds the right result, no extra
test will be generated.

<br><pre>  9 and dup if 1+ then
</pre>

<p>will be compiled as:

<br><pre>  movlw    0x09
  andwf    0x00,f
  btfss    0x03,2
  incf     0x00,f
</pre>

<p>Also, the compiler detects operation which do not modify neither w or the
top of stack. For example,

<br><pre>  dup checksum xor! dcc-high !
</pre>

<p>will be compiled as

<br><pre>  movf    0x00,w
  xorwf   0x6c,f
  incf    0x04,f
  movwf   0x5b
</pre>

<p><hr>
Node:<a name="Increment%2fdecrement%20and%20skip%20if%20zero%20used%20when%20possible">Increment/decrement and skip if zero used when possible</a>,
Next:<a rel=next accesskey=n href="#Values%20are%20not%20normalized%20when%20this%20is%20not%20necessary">Values are not normalized when this is not necessary</a>,
Previous:<a rel=previous accesskey=p href="#Useless%20loads%20removed%20when%20testing">Useless loads removed when testing</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.10 Increment/decrement and skip if zero used when possible</h3>

<p>The following word:

<br><pre>  : action-times ( n -- ) begin action 1- dup while repeat drop ;
</pre>

<p>will be compiled as:

<br><pre>  call    0x022          ; call action
  decfsz  0x00,f
  goto    0x027          ; jump to <code>call action</code> above
  incf    0x04,f
  return
</pre>

<p><hr>
Node:<a name="Values%20are%20not%20normalized%20when%20this%20is%20not%20necessary">Values are not normalized when this is not necessary</a>,
Previous:<a rel=previous accesskey=p href="#Increment%2fdecrement%20and%20skip%20if%20zero%20used%20when%20possible">Increment/decrement and skip if zero used when possible</a>,
Up:<a rel=up accesskey=u href="#Optimizations">Optimizations</a>
<br>

<h3>6.11 Values are not normalized when this is not necessary</h3>

<p>The word:

<br><pre>  :: x ( n -- flag ) 3 &lt; if a then ;
</pre>

<p>generates

<br><pre>  addlw   0xFD
  btfss   0x03,0
  call    a
  return
</pre>

<p>The <code>&lt;</code> test did not cause the value to be normalized to 0 or -1, as it is
not needed.

<p><hr>
Node:<a name="Examples">Examples</a>,
Previous:<a rel=previous accesskey=p href="#Optimizations">Optimizations</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Appendix A Examples</h2>

<p>Some files are included as examples with a Makefile. E.g, to build
<code>booster.hex</code>, run <code>make booster.fs</code>:

<ul>
<li><code>booster.fs</code>
code for a booster which handles overload and overheat signals This also
serves as an example for the priority-based multitasker.

<li><code>generator.fs</code>
code for a DCC signal generator based on serial commands (work in
progress, not functional yet)

<li><code>silver.fs</code>
code that runs on a silver card (a smartcard with a 16f876 and a 24c64
serial eeprom)

<li><code>taskexample.fs</code>
example of multitasking code using the basic multitasker

<li><code>controller.fs</code>
another multitasking example, used to control multiple peripherals and
inputs using a serial link

<li><code>i2cloader.fs</code>
a flash and eeprom loader using an I2C bus to reprogram the PIC

<li><code>spifcard.fs</code>
production code used in the Ambience European project; includes i2c
code, dialog with a bq2010 chip, interface with a smartcard reader using
a TDA8004, interrupt code for implementing an in-house watchdog, working
around I2C bugs and blinking a led, and analog to digital conversion

</ul>


<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Preamble"></a>
    <a href="#Preamble">1 Preamble</a>
<li><a name="toc_Introduction"></a>
    <a href="#Introduction">2 Introduction</a>
<ul>
<li><a href="#What%20is%20that%3f">2.1 What is that?</a>
<li><a href="#Why%20this%20project%3f">2.2 Why this project?</a>
<li><a href="#State%20of%20the%20compiler">2.3 State of the compiler</a>
<li><a href="#License">2.4 License</a>
<li><a href="#Why%20not%20use%20Mary%3f">2.5 Why not use Mary?</a>
<li><a href="#Credits">2.6 Credits</a>
</ul>
<li><a name="toc_A%20very%20short%20Forth%20primer"></a>
    <a href="#A%20very%20short%20Forth%20primer">3 A very short Forth primer</a>
<ul>
<li><a href="#Foreword">3.1 Foreword</a>
<li><a href="#Words">3.2 Words</a>
<li><a href="#Stack%20and%20arguments%20passing">3.3 Stack and arguments passing</a>
<li><a href="#Memory%20access">3.4 Memory access</a>
<li><a href="#Constant%20and%20variables">3.5 Constant and variables</a>
<li><a href="#Tests">3.6 Tests</a>
<li><a href="#Loops">3.7 Loops</a>
</ul>
<li><a name="toc_Our%20first%20PicForth%20program"></a>
    <a href="#Our%20first%20PicForth%20program">4 Our first PicForth program</a>
<ul>
<li><a href="#The%20program%20itself">4.1 The program itself</a>
<li><a href="#Line%20by%20line%20explanation">4.2 Line by line explanation</a>
<li><a href="#Generated%20assembly%20code">4.3 Generated assembly code</a>
<li><a href="#An%20alternate%20solution">4.4 An alternate solution</a>
<li><a href="#Using%20inlined%20code">4.5 Using inlined code</a>
</ul>
<li><a name="toc_Compiler%20documentation"></a>
    <a href="#Compiler%20documentation">5 Compiler documentation</a>
<ul>
<li><a href="#Organisation">5.1 Organisation</a>
<li><a href="#Compiling">5.2 Compiling</a>
<li><a href="#Code">5.3 Code</a>
<li><a href="#Interactive%20mode">5.4 Interactive mode</a>
<li><a href="#Literals">5.5 Literals</a>
<li><a href="#Default%20base">5.6 Default base</a>
<li><a href="#Stack%20size">5.7 Stack size</a>
<li><a href="#Shifting">5.8 Shifting</a>
<li><a href="#Looping">5.9 Looping</a>
<li><a href="#Memory">5.10 Memory</a>
<li><a href="#Variables">5.11 Variables</a>
<li><a href="#Tables">5.12 Tables</a>
<li><a href="#Main%20program">5.13 Main program</a>
<li><a href="#Macros">5.14 Macros</a>
<li><a href="#Included%20files">5.15 Included files</a>
<li><a href="#Assembler">5.16 Assembler</a>
<li><a href="#Interrupts">5.17 Interrupts</a>
<li><a href="#Argument%20passing">5.18 Argument passing</a>
<li><a href="#Bit%20manipulation">5.19 Bit manipulation</a>
<li><a href="#Decrementing%20and%20incrementing%20a%20memory%20register">5.20 Decrementing and incrementing a memory register</a>
<li><a href="#Watchdog%20timer">5.21 Watchdog timer</a>
<li><a href="#Reading%20from%20or%20writing%20to%20EEPROM">5.22 Reading from or writing to EEPROM</a>
<li><a href="#Reading%20from%20or%20writing%20to%20flash%20memory">5.23 Reading from or writing to flash memory</a>
<li><a href="#Map%20and%20disassembler%20code">5.24 Map and disassembler code</a>
<li><a href="#Multitasking">5.25 Multitasking</a>
<ul>
<li><a href="#Priority-based%20multitasker">5.25.1 Priority-based multitasker</a>
<li><a href="#Basic%20cooperative%20multitasker">5.25.2 Basic cooperative multitasker</a>
</ul>
<li><a href="#Libraries">5.26 Libraries</a>
<li><a href="#Configuration%20word">5.27 Configuration word</a>
<li><a href="#Caveats%20and%20limitations">5.28 Caveats and limitations</a>
</ul>
<li><a name="toc_Optimizations"></a>
    <a href="#Optimizations">6 Optimizations</a>
<ul>
<li><a href="#Tail%20recursion">6.1 Tail recursion</a>
<li><a href="#Redundant%20pop%2fpush%20are%20removed">6.2 Redundant pop/push are removed</a>
<li><a href="#Direct-access%20and%20literal%20variants">6.3 Direct-access and literal variants</a>
<li><a href="#Load">6.4 Load, store and operations are mixed</a>
<li><a href="#Condition%20inversions">6.5 Condition inversions</a>
<li><a href="#Bank%20switch%20optimizations">6.6 Bank switch optimizations</a>
<li><a href="#Operation%20retarget">6.7 Operation retarget</a>
<li><a href="#Bit%20test%20operations">6.8 Bit test operations</a>
<li><a href="#Useless%20loads%20removed%20when%20testing">6.9 Useless loads removed when testing</a>
<li><a href="#Increment%2fdecrement%20and%20skip%20if%20zero%20used%20when%20possible">6.10 Increment/decrement and skip if zero used when possible</a>
<li><a href="#Values%20are%20not%20normalized%20when%20this%20is%20not%20necessary">6.11 Values are not normalized when this is not necessary</a>
</ul>
<li><a name="toc_Examples"></a>
    <a href="#Examples">Appendix A Examples</a>
</ul>

</body></html>

